## 引言

CTF逆向题目中，RC4加密算法常与异或、文件操作等场景结合，本题以“勒索病毒”为载体，将密钥验证与RC4加密隐藏在程序逻辑中。题目看似需要充值解密，实则可通过IDA逆向分析找到密钥验证逻辑，再利用异或解密获取密钥，最终完成flag提取。本文将详细拆解逆向流程，从程序逻辑分析到密钥破解，再到RC4算法验证，一步步还原解题过程。

## 题目环境与初步分析

### 1. 题目文件
- 核心文件：`勒索病毒.exe`（32位/64位应用程序）
- 加密文件：`enflag.txt`（存储加密后的flag，表现为乱码）
- 缺失文件：`flag.txt`（程序读取的源文件，需手动创建）

### 2. 初步运行测试
运行`勒索病毒.exe`后，程序给出两个选项：
```
**************************我的Flag出了什么问题??**************************
您的一些重要数据被我们加密了,就算您叫破喉咙来也没有办法恢复。
**************************那有没有恢复的方法呢??**************************
有的。只能通过我们的财付通,支付宝服务才能恢复,我以人格担保,只要充钱,就能解密
做出你的选择:
1.充钱
2.退出
```
选择“1.充钱”后，程序提示“打开源文件失败”，原因是当前目录缺少`flag.txt`。手动创建空的`flag.txt`后，程序会要求输入密钥，输入错误则提示“Error!”，输入正确则完成解密。

## IDA逆向分析核心流程

### 1. 定位main函数与程序逻辑
使用IDA64反编译`勒索病毒.exe`，定位到主函数`main_0`，核心逻辑如下：
1. 显示勒索提示信息，接收用户选择（充钱/退出）；
2. 选择“充钱”后，尝试打开`flag.txt`（源文件）和`enflag.txt`（加密文件）；
3. 接收用户输入的密钥（Str），调用`sub_401069`处理密钥；
4. 调用`sub_401028`执行加密/解密操作。  

关键代码片段：
```c
// 接收用户密钥输入
sub_401037("\n请输入您的密钥:", v4);
sub_401073("%s", (char)Str);
sub_401069(Str, Str1);  // 密钥处理函数
sub_401028(Str, v15, v14, v13, v12);  // 核心加解密函数
```

### 2. 追踪密钥验证函数`sub_401069`
跟进`sub_401069`发现其调用`sub_401A70`，后者是密钥验证的核心逻辑：
```c
char __cdecl sub_401A70(char *Str, char *Str1)
{
    char v3; // [esp+0h] [ebp-E4h]
    signed int i; // [esp+D0h] [ebp-14h]
    signed int v5; // [esp+DCh] [ebp-8h]

    CheckForDebuggerJustMyCode(&unk_40B027);
    v5 = strlen(Str);
    for (i = 0; i < v5; ++i)
        Str1[i] += Str[i] ^ 0x1F;  // 密钥异或处理
    if (!strcmp(Str1, "DH~mqqvqxB^^||zll@Jq~jkwpmvez{"))
        sub_401037("充值成功. \n", v3);  // 密钥正确
    else
        sub_401037("Error!\n", v3);  // 密钥错误
    return *Str1;
}
```

核心逻辑：
- 用户输入的密钥`Str`中每个字符与`0x1F`异或；
- 异或结果与固定字符串`"DH~mqqvqxB^^||zll@Jq~jkwpmvez{"`比较；
- 一致则密钥正确，不一致则报错。

### 3. 异或解密获取密钥
异或运算满足“两次异或同一值还原原始数据”，即`original = cipher ^ key`。已知`Str1[i] = Str[i] ^ 0x1F`，且`Str1`的目标值已知，因此反向计算可得`Str[i] = Str1[i] ^ 0x1F`。

编写Python脚本解密：
```python
# 目标字符串（Str1的正确值）
str1 = "DH~mqqvqxB^^||zll@Jq~jkwpmvez{"
key = ""
for c in str1:
    # 异或0x1F还原原始密钥字符
    key += chr(ord(c) ^ 0x1F)
print("解密得到密钥：", key)
```

运行结果：
```
解密得到密钥：[Warnning]Access_Unauthorized
```

### 4. RC4算法验证（可选）
继续逆向`sub_401028`可发现其内部实现了完整的RC4算法（KSA初始化+PRGA密钥流生成），因此也可直接提取`enflag.txt`中的密文，使用密钥`[Warnning]Access_Unauthorized`通过CyberChef的RC4解密功能直接获取flag，结果与程序解密一致。

## 完整解题步骤

### 1. 环境准备
1. 在程序目录下创建空文件`flag.txt`（解决“打开源文件失败”问题）；
2. 保存上述Python脚本为`get_key.py`，运行获取密钥`[Warnning]Access_Unauthorized`。

### 2. 执行解密
1. 运行`勒索病毒.exe`，选择“1.充钱”；
2. 输入解密得到的密钥`[Warnning]Access_Unauthorized`，提示“充值成功”；
3. 打开`enflag.txt`，即可看到解密后的flag。

### 3. 直接RC4解密（备选方案）
若无需运行程序，可直接通过CyberChef解密：
1. 打开CyberChef，选择“RC4”加密算法；
2. 输入`enflag.txt`中的密文（复制乱码内容）；
3. 密钥填写`[Warnning]Access_Unauthorized`；
4. 执行解密，直接得到flag。

## 关键技术点总结

### 1. 异或解密的核心原理
- 异或运算的可逆性：`a ^ b ^ b = a`，是CTF逆向中最常见的解密手段；
- 本题中固定异或值`0x1F`（ASCII码中的控制字符），需通过逆向代码识别目标字符串。

### 2. RC4算法的应用场景
- RC4算法分为KSA初始化和PRGA密钥流生成两个阶段，本题中`sub_401028`实现了完整流程；
- 对于已知密钥的RC4加密，可直接使用工具（CyberChef、Python的`rc4`库）解密，无需重复编写代码。

### 3. 程序文件操作的坑点
- 程序依赖`flag.txt`的存在（即使为空），否则无法进入密钥输入环节；
- `enflag.txt`是加密后的flag存储文件，解密后直接修改该文件内容。

## 总结

本题的核心难点在于通过IDA逆向找到密钥验证的异或逻辑，而非RC4算法本身。解题过程中，我们先通过程序运行现象定位缺失文件问题，再通过逆向追踪关键函数，最终利用异或可逆性破解密钥。对于CTF逆向中的“勒索病毒”类题目，往往无需真的“充值”，而是通过分析程序逻辑找到漏洞或密钥验证机制，即可绕过程序限制完成解密。

掌握异或解密、IDA基本操作和RC4算法原理，能快速解决此类结合经典加密算法的逆向题目。如果在逆向过程中遇到调试困难，可尝试直接提取密文和密钥，通过工具验证加密算法类型，提高解题效率。